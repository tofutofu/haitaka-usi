// USI - Universal Shogi Interface protocol
//
// References: 
// - UCI protocol (https://backscattering.de/chess/uci/)
// - The Universal Shogi Interface (http://hgm.nubati.net/usi.html)
// - https://shogidokoro2.stars.ne.jp/usi.html 
//
// Both the UCI protocol and the initial version of the USI protocol (the second link above)
// are vague about details, edge cases and error conditions. The UCI protocol also made some
// unfortunate, bad design decisions that make the protocol brittle and that make it more
// difficult to implement the spec. In particular, the decision to _silently 
// ignore_ leading and trailing garbage tokens seems rather questionable.
//
// Requirements:
//
// - All communication between engine and GUI is done by 7-bit ASCII text.
// - All command strings must end with '\n'. All viable end-of-line characters should be
//   handled ('\n', '\r', or any combination).
// - Arbitrary white space between tokens is allowed. Note the spec does not define "white space".
//   I will defined it as any ascii white-space (' ', '\t', '\v', '\f').
// - If the engine or the GUI receives an unknown command or token it should just ignore it 
//   and try to parse the rest of the line. Examples: 
//   - `joho debug on\n` should switch the debug mode on given that joho is not defined, 
//   - `debug joho on\n` will be undefined however.
//   So, apparently this means that unparsable prefixes and suffixes of commands should be ignored.
// - If the engine receives a command that is unexpected, for example `stop` when 
//   the engine is not calculating, it should also just ignore it. (This doesn't involve syntax,
//   but semantics.)
// - All options with fixed semantics start with the prefix "USI_". For instance, 
//   the option which is named Hash in UCI is named USI_Hash in USI. 
// 
// Case-sensitivity
// ----------------
// The ref doesn't specify whether or not commands are case-sensitive. Stockfish only accepts 
// lowercased commands. I will also assume that all commands must be in lower case; I believe
// this is in the spirit of the spec. But all user-specified strings, names, options are
// treated as case-sensitive unless the spec explicitly demands case-insensitive handling (as it
// does for options).
//
// Numbers
// -------
// I chose to not put any restrictions in the syntax on numbers. Checking that a value
// makes sense should imo be done in the parser. One reason of not restricting this on a too 
// low level is also that it gives the parser and engine more freedom
// (e.g. the freedom to allow very long mate problems with over a 1000 moves as input).
// A more principled reason is that the USI spec doesn't specify any restrictions. 
//
// The published specs say practically nothing about error conditions. For instance:
// Should `go ponderosa` be parsed as `go ponder`, ignoring the trailing `osa`? Or should it 
// be an error? Should `debugon` and `de bugon` be parsed as `debug on`, or as garbage?
// Since the spec talks about "tokens" (without defining those), it seems reasonable to interpret 
// all keywords as "tokens" and to require that all tokens must be delimited either by white-space 
// (excluding newlines) or SOI (start of input) or EOI (end of input). In the grammar below, 
// I have enforced this by using a special "boundary" marker (`KB`) on messages.
//
// Details (from Shogidokoro)
// --------------------------
//
// - When a SFEN string encodes an arbitrary position, the move number doesn't really make sense
// anymore. So, we can arbitrarily set it to 1 (or expect it to be set to 1).
// 

WHITESPACE = _{ " " | "\t" }
WS = _{ WHITESPACE+ }
NL = _{ WHITESPACE | NEWLINE }
SEP = _{"/"}

// boundary
KB = _{ WHITESPACE* ~ NEWLINE } 

// start 
start = _{ SOI ~ NL* ~ (line ~ NL*)+ ~ &EOI }

// we need to allow trailing and ending garbage
line = _{ garbage? ~ message ~ garbage? }

garbage = _{ !NEWLINE ~ !start_of_command ~ ANY+ }

// garbage = _{ !start_of_command ~ ANY+ }

start_of_command = _{ 
    "usi" | 
    "debug" | 
    "isready" | 
    "setoption" | 
    "register" | 
    "usinewgame" | 
    "stop" | 
    "ponderhit" | 
    "quit" | 
    "position" |
    "go" | 
    "id" | 
    "usiok" | 
    "readyok" | 
    "bestmove" |
    "copyprotection" |
    "registration" |
    "option" |
    "info" |
    "gameover"
}

// message
message = _{
    usi | 
    debug | 
    isready | 
    setoption | 
    register | 
    usinewgame | 
    stop | 
    ponderhit | 
    quit |
    position | 
    go |
    id | 
    usiok | 
    readyok | 
    bestmove | 
    copyprotection | 
    registration | 
    option | 
    info |
    gameover
}

//
// GuiMessage: GUI to engine
//

usi = ${ "usi" ~ &KB }

debug = ${ "debug" ~ (WS ~ ("on" | "off"))? ~ &KB }

isready = { "isready" ~ &KB }

setoption = ${ "setoption" ~ WS ~ "name" ~ WS ~ setoption_name ~ (WS ~ "value" ~ WS ~ setoption_value)? }

    // "The name and value of the option in id should not be case sensitive and CAN inlude spaces."
    // `value` will consume until EOL
    // if no value is found, then `name` may consume rest of line
    setoption_name = ${ setoption_token ~ (WS ~ setoption_token)* }
    setoption_token = _{ !("value") ~ token }
    setoption_value = ${ tokens }

register = { register_later | register_with_name_and_code }

    register_later = ${ "register" ~ WS ~ "later" ~ &KB}
    register_with_name_and_code = ${ "register" ~ WS ~ "name" ~ WS ~ register_name ~ WS ~ "code" ~ WS ~ register_code }

    // `code` consume until EOL
    register_name = ${ register_token ~ (WS ~ register_token)* }
    register_token = _{ !("code") ~ token }
    register_code = ${ tokens }

usinewgame = { "usinewgame" ~ &KB}

stop = { "stop" ~ &KB }

quit = { "quit" ~ &KB }

ponderhit = { "ponderhit" ~ &KB }

gameover = ${ "gameover" ~ WS ~ (win | lose | draw) ~ &KB }
    
    win = { "win" }
    lose = { "lose" }
    draw = { "draw" }

position = ${ "position" ~ WS ~ (startpos | sfenpos) ~ (WS ~ "moves" ~ WS ~ moves)? ~ &KB }

    startpos = ${ "startpos" }
    sfenpos = ${ "sfen" ~ WS ~ sfen_board ~ WS ~ sfen_color ~ WS ~ sfen_hands ~ (WS ~ sfen_move_num)? }

    sfen_board = ${ (sfen_rank ~ SEP){8} ~ sfen_rank }
    sfen_color = ${ "w" | "b" }
    sfen_hands = ${ sfen_black_hand ~ sfen_white_hand? | sfen_white_hand | sfen_empty_hand }
    sfen_move_num = ${ digits }  

    sfen_rank = ${ ((prom? ~ (white_piece | black_piece)) | file){1,9} }

    sfen_black_hand = ${ (npieces? ~ black_hand_piece){1,6} }
    sfen_white_hand = ${ (npieces? ~ white_hand_piece){1,6} }
    sfen_empty_hand = { "-" }

    prom = { "+" }
    white_piece = { "k" | "r"  | "b" | "g" | "s" | "n"  | "l"  | "p" }
    black_piece = { "K" | "R"  | "B" | "G" | "S" | "N"  | "L"  | "P" }
    white_hand_piece = { "r"  | "b" | "s" | "n"  | "l"  | "p" }
    black_hand_piece = { "R"  | "B" | "S" | "N"  | "L"  | "P" }

    // "1" should really not be used, but I'll allow it
    npieces = { "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" | 
                "10" | "11" | "12" | "13" | "14" | "15" | "16" | "17" | "18" }

    moves = ${ one_move ~ (WS ~ one_move)* }

    one_move = { drop | board_move }
    drop = ${ black_piece ~ "*" ~ square }
    board_move = ${ square ~ square ~ "+"? }

    square = ${ file ~ rank }
    file = { '1'..'9' }
    rank = { 'a'..'i' }

go = ${ "go" ~ (WS ~ go_sub_cmd)* ~ &KB }

    go_sub_cmd = _{
        searchmoves |          
        ponder |
        movetime |
        byoyomi |
        movestogo |
        wtime |
        btime |
        winc |
        binc |
        depth |
        nodes | 
        mate |
        infinite
    }

    searchmoves = ${ "searchmoves" ~ WS ~ moves}
    ponder = { "ponder" }
    movetime = ${ "movetime" ~ WS ~ millisecs }
    byoyomi = ${ "byoyomi" ~ WS ~ millisecs }
    wtime = ${ "wtime" ~ WS ~ millisecs }
    btime = ${ "btime" ~ WS ~ millisecs }
    winc = ${ "winc" ~ WS ~ millisecs }
    binc = ${ "binc" ~ WS ~ millisecs }
    movestogo = ${ "movestogo" ~ WS ~ digits }
    depth = ${ "depth" ~ WS ~ digits }
    nodes = ${ "nodes" ~ WS ~ digits }
    mate = ${ "mate" ~ WS ~ digits }
    infinite = { "infinite" }

//
// EngineMessage: Engine to GUI
//

id = ${ "id" ~ WS ~ (id_name | id_author) }

    // consume until EOL
    id_name = ${ "name" ~ WS ~ tokens }
    id_author = ${ "author" ~ WS ~ tokens }

usiok = { "usiok" ~ &KB }

readyok = { "readyok" ~ &KB }

bestmove = ${ "bestmove" ~ WS ~ one_move ~ (WS ~ ponder_move)? ~ &KB }

    ponder_move = { "ponder" ~ WS ~ one_move }

copyprotection = ${ "copyprotection" ~ WS ~ status_check ~ &KB }

registration = ${ "registration" ~ WS ~ status_check ~ &KB }

    status_check = { "checking" | "ok" | "error" }

// Option examples
// ---------------
// option name Nullmove type check default true\n
// option name Selectivity type spin default 2 min 0 max 4\n
// option name Style type combo default Normal var Solid var Normal var Risky\n
// option name NalimovPath type string default c:\\n
// option name Clear Hash type button\n
//
// Note: "One string will be sent for each parameter."
// "Certain options have a fixed value for id, which means that the semantics of this option is fixed."
// For Shogi those have prefix "USI_" rather than "UCI_".

// Spaces are not allowed in option names. It seems they are allowed in option values (in particular in
// the 'string' or 'filename' option). Nothing is specified about any escape characters.

option = ${ "option" ~ WS ~ (check_option | spin_option | combo_option | string_option | button_option | filename_option) ~ &KB }

    check_option = ${ option_name ~ WS ~ "type" ~ WS ~ "check" ~ (WS ~ "default" ~ WS ~ check_default)? }
    spin_option = ${ option_name ~ WS ~ "type" ~ WS ~ "spin" ~ (WS ~ "default" ~ WS ~ spin_default)? ~ (WS ~ spin_min)? ~ (WS ~ spin_max)? }
    combo_option = ${ option_name ~ WS ~ "type" ~ WS ~ "combo" ~ (WS ~ "default" ~ WS ~ default)? ~ (WS ~ "var" ~ WS ~ var)* }
    string_option = ${ option_name ~ WS ~ "type" ~ WS ~ "string" ~ (WS ~ "default" ~ WS ~ default)? }
    button_option = ${ option_name ~ WS ~ "type" ~ WS ~ "button" }
    filename_option = ${ option_name ~ WS ~ "type" ~ WS ~ "filename" ~ (WS ~ "default" ~ WS ~ default)? }

    option_name = ${ "name" ~ WS ~ name_token }
    name_token = ${ !("type") ~ token }
    
    check_default = { "true" | "false" }
    spin_default = { integer }
    spin_min = ${ "min" ~ WS ~ integer }
    spin_max = ${ "max" ~ WS ~ integer }
    default = ${ "default" ~ WS ~ var_token }
    var = { !("var") ~ var_token }
    var_token = ${ !("default" | "var") ~ token}
    
// Info examples
// -------------
//  info currmove e2e4 currmovenumber 1
// 	info depth 12 nodes 123456 nps 100000
//
// The spec says that "all infos belonging to the pv should be sent together", e.g.
//
//  info depth 2 score cp 214 time 1242 nodes 2124 nps 34928 pv 2g2f 8c8d 2f2e 8d8e
//
// however, it forgets to mention which infos always "belong to" the pv.
// The 'pv' apparently always ends an info command, so it can also not go togeter with the
// 'info string ...' message (Shogidokoro).
//
//  info depth 1 seldepth 0
//  info score cp 13  depth 1 nodes 13 time 15 pv 2g2f
//  info depth 2 seldepth 2
//  info nps 15937
//  info score cp 14  depth 2 nodes 255 time 15 pv 2g2f 8c8d
//  info depth 2 seldepth 7 nodes 255
//  info depth 3 seldepth 7
//  info nps 26437
//  info score cp 20  depth 3 nodes 423 time 15 pv 2g2f P*8f
//  info nps 41562

info = ${ "info" ~ (WS ~ info_attr)+ ~ &KB }

    info_attr = _{
        info_depth |
        info_seldepth |
        info_time | 
        info_nodes | 
        info_currmovenum | 
        info_currmove | 
        info_hashfull | 
        info_nps |
        info_cpuload | 
        info_pv | 
        info_multipv | 
        info_refutation | 
        info_currline |
        info_score_cp |
        info_score_mate |
        info_string
    }

    info_depth = ${ "depth" ~ WS ~ digits }
    info_seldepth = ${ "seldepth" ~ WS ~ digits }
    info_time = ${ "time" ~ WS ~ millisecs }
    info_nodes = ${ "nodes" ~ WS ~ digits }
    info_currmove = ${ "currmove" ~ WS ~ one_move }
    info_currmovenum = ${ "currmovenum" ~ WS ~ digits }
    info_hashfull = ${ "hashfull" ~ WS ~ digits }
    info_nps = ${ "nps" ~ WS ~ digits }
    info_cpuload = ${ "cpuload" ~ WS ~ digits }    
    info_pv = ${ "pv" ~ WS ~ moves }
    // multipv should be more restricted perhaps, since multiple multipv commands need to
    // be sent in separate commands
    info_multipv = ${ "multipv" ~ WS ~ digits }
    info_refutation = ${ "refutation" ~ WS ~ moves }

    // "currline: If cpunr is greater than 1, always send all k lines in k strings together."
    // I assume that means, send multiple new-line separated `currline` messages.
    // `cpunr` should then only occur at most once in each expression. The quote illustrates
    // the extreme vagueness of the spec.
    info_currline = ${ "currline" ~ WS ~ (digits ~ WS)? ~ moves }

    // Assuming that `score cp x` and `score mate x` are never sent as `info score cp x mate y`. 
    // Shogidokoro: `score mate +` means the engine has a discovered a forced mate, but cannot tell
    // how many moves. Similarly `score mate -` means the engine has discovered that the opponent
    // has a forced mate against the engine, but it cannot tell how many moves this has.
    info_score_cp = ${ "score" ~ WS ~ "cp" ~ WS ~ integer ~ (WS ~ (lowerbound | upperbound))? }
    info_score_mate = ${ "score" ~ WS ~ "mate" ~ WS ~ ((integer ~ (WS ~ (lowerbound | upperbound))?) | sign) }

        lowerbound = { "lowerbound" }
        upperbound = { "upperbound" }

    // consumes until EOL
    info_string = ${ "string" ~ WS ~ tokens }

//
// helpers 
// 

// a token is a contiguous sequence of chars, but with no whitespace or newlines
token = @{ (!(WHITESPACE | NEWLINE) ~ ANY)+ }

// tokens is a sequence of white-space-separated tokens (but not allowing newlines)
tokens = @{ token ~ (WS ~ token)* }

// digits is a contiguous sequence of ascii digits
digits = @{ ASCII_DIGIT+ }

millisecs = { digits }
integer = { sign? ~ digits }
sign = { "+" | "-" }




