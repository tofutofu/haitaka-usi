// USI - Universal Shogi Interface protocol
//
// References: 
// - UCI protocol (https://backscattering.de/chess/uci/)
// - The Universal Shogi Interface (http://hgm.nubati.net/usi.html)
// - https://shogidokoro2.stars.ne.jp/usi.html 
//
// Both the UCI protocol and the draft version of the USI protocol (the second link above)
// are vague about details, edge cases and error conditions. The UCI protocol also made some
// very unfortunate, bad design decisions that make the protocol brittle and make more difficult
// to implement. In particular, the decision to _silently  ignore_ junk tokens was questionable.
// The Japanese spec by Shogidokoro is clearer on some details and on actual usage, so I am
// taking that as my basis.
//
// Requirements
// ------------
// - All communication between engine and GUI is done by 7-bit ASCII text.
//   This seems to imply that non-ascii text should be rejected. The spec is not
//   very clear if this is indeed the case for the `info string ...` and `info filename ...`
//   commands. There is also no length restriction on those two commands; in some cases they
//   could pose security risks. In the grammar below I strictly require ASCII in all commands
//   including in option names and values, but do allow non-ASCII characters in junk portions
//   (which are to be ignored).
// - All command strings must end with '\n'. All viable end-of-line characters should be
//   handled ('\n', '\r', or any combination). PEST NEWLINE handles this.
// - Arbitrary white space between tokens is allowed. The spec does not define "white space".
//   I define it as any ASCII white-space (' ', '\t')(excluding '\v' and '\f').
// - If the engine or the GUI receives an unknown command or token "it should just ignore it 
//   and try to parse the rest of the line". Examples: 
//   - `joho debug on\n` should switch the debug mode on given that joho is not defined, 
//   - `debug joho on\n` will be undefined however.
//   Apparently this means that unparsable _prefixes_ should be ignored. In the grammar here
//   I allow leading junk but no trailing junk on any given line.
// - If the engine receives a command that is unexpected, for example `stop` when 
//   the engine is not calculating, it should also just ignore it. This is not handled by
//   the grammar, but can only be handled by the parser or Engine code.
// - All options with fixed semantics start with the prefix "USI_". For instance, 
//   the option which is named Hash in UCI is named USI_Hash in USI. This is not handled by
//   the grammar. The only restriction here is that option names should all be in ASCII and 
//   should not contain any whitespace (which differs from the UCI protocol).
// 
// Case-sensitivity
// ----------------
// The spec doesn't specify whether or not command tokens are case-sensitive. Stockfish only accepts 
// lowercased commands. In the grammar below all command tokens and key words are expected to be 
// ASCII lower case.
//
// Errors and tokens
// -----------------
// The published specs say nothing about error conditions or about what to expect in case of error. 
// For instance: Should `go ponderosa` be parsed as `go ponder`, ignoring the trailing `osa`? Or should
// it be an error? Should `debugon` be parsed as `debug on` or as junk? How about "usi usi"?
// Since the spec talks about "tokens" (without defining those!), it seems reasonable to interpret 
// all keywords as "tokens" and to require that all tokens must be delimited either by white-space 
// (excluding newlines) or SOI (start of input) or EOI (end of input). 
//
// PEST/PEG
// --------
//
// - `ANY` matches any single Unicode code point, including whitespace and newline. This is not
//    clearly documented, but can be verified in the fiddle editor (https://pest.rs/#editor). The
//    grammar below only using ANY in junk messages; all regular messages need to be in ASCII.
//

WHITESPACE = _{ " " | "\t" }
WS = _{ WHITESPACE+ }
NL = _{ WHITESPACE | NEWLINE }
SEP = _{"/"}

// start 
start = _{SOI ~ line+ ~ &EOI}
line = _{ other? ~ (delimited_message|junk) }

delimited_message = _{ NL* ~ message ~ WHITESPACE* ~ NEWLINE }

message = _{ gui_message | engine_message | other}

// other 
other = @{ (!gui_message ~ !engine_message ~ !NEWLINE ~ ANY)+ }
junk = @{ (!NEWLINE ~ ANY)* ~ NEWLINE}

// message
gui_message = _{
    usi | 
    debug | 
    isready | 
    setoption | 
    register | 
    usinewgame | 
    stop | 
    ponderhit | 
    quit |
    position | 
    go |
    gameover
}

engine_message = _{
    id | 
    usiok | 
    readyok | 
    bestmove | 
    copyprotection | 
    registration | 
    option | 
    info
}

//
// GuiMessage: GUI to engine
//

usi = ${ "usi" ~ &NL }

debug = ${ "debug" ~ (WS ~ ("on" | "off"))?  }

isready = ${ "isready"  }

setoption = ${ "setoption" ~ WS ~ "name" ~ WS ~ setoption_name ~ (WS ~ "value" ~ WS ~ setoption_value)? }

    // "The name and value of the option in id should not be case sensitive and CAN NOT inlude spaces."
    // That _seems_ to mean that the value can also not include spaces.
    setoption_name = ${ !("value") ~ token }
    setoption_value = ${ token }

register = ${ register_later | register_with_name_and_code }

    register_later = { "register" ~ WS ~ "later" }
    register_with_name_and_code = { "register" ~ WS ~ "name" ~ WS ~ register_name ~ WS ~ "code" ~ WS ~ register_code }
    register_name = { register_token ~ (WS ~ register_token)* }
    register_token = _{ !("code") ~ token }
    register_code = { tokens }

usinewgame = ${ "usinewgame" }

stop = ${ "stop"  }

quit = ${ "quit"  }

ponderhit = ${ "ponderhit"  }

gameover = ${ "gameover" ~ WS ~ (win | lose | draw)  }
    
    win = { "win" }
    lose = { "lose" }
    draw = { "draw" }

position = ${ "position" ~ WS ~ (startpos | sfenpos) ~ (WS ~ "moves" ~ WS ~ moves)?  }

    startpos = { "startpos" }
    sfenpos = { "sfen" ~ WS ~ sfen_board ~ WS ~ sfen_color ~ WS ~ sfen_hands ~ (WS ~ sfen_move_num)? }

    sfen_board = { (sfen_rank ~ SEP){8} ~ sfen_rank }
    sfen_color = { "w" | "b" }
    sfen_hands = { sfen_black_hand ~ sfen_white_hand? | sfen_white_hand | sfen_empty_hand }
    sfen_move_num = { digits }  

    sfen_rank = { ((prom? ~ (white_piece | black_piece)) | file){1,9} }

    sfen_black_hand = { (npieces? ~ black_hand_piece){1,6} }
    sfen_white_hand = { (npieces? ~ white_hand_piece){1,6} }
    sfen_empty_hand = { "-" }

    prom = { "+" }
    white_piece = { "k" | "r"  | "b" | "g" | "s" | "n"  | "l"  | "p" }
    black_piece = { "K" | "R"  | "B" | "G" | "S" | "N"  | "L"  | "P" }
    white_hand_piece = { "r"  | "b" | "s" | "n"  | "l"  | "p" }
    black_hand_piece = { "R"  | "B" | "S" | "N"  | "L"  | "P" }

    // "1" should really not be used, but I'll allow it
    npieces = { "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" | 
                "10" | "11" | "12" | "13" | "14" | "15" | "16" | "17" | "18" }

    moves = { one_move ~ (WS ~ one_move)* }

    one_move = { drop | board_move }
    drop = { black_piece ~ "*" ~ square }
    board_move = { square ~ square ~ "+"? }

    square = { file ~ rank }
    file = { '1'..'9' }
    rank = { 'a'..'i' }

go = ${ "go" ~ (WS ~ go_sub_cmd)*  }

    go_sub_cmd = _{
        searchmoves |          
        ponder |
        movetime |
        byoyomi |
        movestogo |
        wtime |
        btime |
        winc |
        binc |
        depth |
        nodes | 
        mate |
        infinite
    }

    searchmoves = { "searchmoves" ~ WS ~ moves}
    ponder = { "ponder" }
    movetime = { "movetime" ~ WS ~ millisecs }
    byoyomi = { "byoyomi" ~ WS ~ millisecs }
    wtime = { "wtime" ~ WS ~ millisecs }
    btime = { "btime" ~ WS ~ millisecs }
    winc = { "winc" ~ WS ~ millisecs }
    binc = { "binc" ~ WS ~ millisecs }
    movestogo = { "movestogo" ~ WS ~ digits }
    depth = { "depth" ~ WS ~ digits }
    nodes = { "nodes" ~ WS ~ digits }
    // following Shogidokoro semantics
    mate = { "mate" ~ WS ~ (infinite | millisecs) }
    infinite = { "infinite" }

//
// EngineMessage: Engine to GUI
//

id = ${ "id" ~ WS ~ (id_name | id_author) }

    // consume until EOL
    id_name = ${ "name" ~ WS ~ tokens }
    id_author = ${ "author" ~ WS ~ tokens }

usiok = { "usiok"  }

readyok = { "readyok"  }

bestmove = ${ "bestmove" ~ WS ~ one_move ~ (WS ~ ponder_move)?  }

    ponder_move = { "ponder" ~ WS ~ one_move }

copyprotection = ${ "copyprotection" ~ WS ~ status_check  }

registration = ${ "registration" ~ WS ~ status_check  }

    status_check = { "checking" | "ok" | "error" }

option = ${ "option" ~ WS ~ (check_option | spin_option | combo_option | string_option | button_option | filename_option)  }

    check_option = ${ option_name ~ WS ~ "type" ~ WS ~ "check" ~ (WS ~ "default" ~ WS ~ check_default)? }
    spin_option = ${ option_name ~ WS ~ "type" ~ WS ~ "spin" ~ (WS ~ "default" ~ WS ~ spin_default)? ~ (WS ~ spin_min)? ~ (WS ~ spin_max)? }
    combo_option = ${ option_name ~ WS ~ "type" ~ WS ~ "combo" ~ (WS ~ "default" ~ WS ~ default)? ~ (WS ~ "var" ~ WS ~ var)* }
    string_option = ${ option_name ~ WS ~ "type" ~ WS ~ "string" ~ (WS ~ "default" ~ WS ~ default)? }
    button_option = ${ option_name ~ WS ~ "type" ~ WS ~ "button" }
    filename_option = ${ option_name ~ WS ~ "type" ~ WS ~ "filename" ~ (WS ~ "default" ~ WS ~ default)? }

    // option_name can not contain spaces
    option_name = ${ "name" ~ WS ~ name_token }
    name_token = ${ !("type") ~ token }
    
    check_default = { "true" | "false" }
    spin_default = { integer }
    spin_min = ${ "min" ~ WS ~ integer }
    spin_max = ${ "max" ~ WS ~ integer }
    default = ${ "default" ~ WS ~ var_token }
    var = { !("var") ~ var_token }
    var_token = ${ !("default" | "var") ~ token}
    
info = ${ "info" ~ (WS ~ info_attr)+  }

    info_attr = _{
        info_depth |
        info_seldepth |
        info_time | 
        info_nodes | 
        info_currmovenum | 
        info_currmove | 
        info_hashfull | 
        info_nps |
        info_cpuload | 
        info_pv | 
        info_multipv | 
        info_refutation | 
        info_currline |
        info_score_cp |
        info_score_mate |
        info_string
    }

    info_depth = ${ "depth" ~ WS ~ digits }
    info_seldepth = ${ "seldepth" ~ WS ~ digits }
    info_time = ${ "time" ~ WS ~ millisecs }
    info_nodes = ${ "nodes" ~ WS ~ digits }
    info_currmove = ${ "currmove" ~ WS ~ one_move }
    info_currmovenum = ${ "currmovenum" ~ WS ~ digits }
    info_hashfull = ${ "hashfull" ~ WS ~ digits }
    info_nps = ${ "nps" ~ WS ~ digits }
    info_cpuload = ${ "cpuload" ~ WS ~ digits }    
    info_pv = ${ "pv" ~ WS ~ moves }
    // multipv should be more restricted perhaps, since multiple multipv commands need to
    // be sent in separate commands
    info_multipv = ${ "multipv" ~ WS ~ digits }
    info_refutation = ${ "refutation" ~ WS ~ moves }

    // "Currline: If cpunr is greater than 1, always send all k lines in k strings together."
    // I assume that means, send multiple new-line separated `currline` messages.
    // `cpunr` should then only occur at most once in each expression. 
    info_currline = ${ "currline" ~ WS ~ (digits ~ WS)? ~ moves }

    // I assume that `score cp x` and `score mate x` are never sent as `info score cp x mate y`. 
    // Shogidokoro: `score mate +` means the engine has a discovered a forced mate, but cannot tell
    // how many moves. Similarly `score mate -` means the engine has discovered that the opponent
    // has a forced mate against the engine, but it cannot tell how many moves this has.
    info_score_cp = ${ "score" ~ WS ~ "cp" ~ WS ~ integer ~ (WS ~ (lowerbound | upperbound))? }
    info_score_mate = ${ "score" ~ WS ~ "mate" ~ WS ~ ((integer ~ (WS ~ (lowerbound | upperbound))?) | (plus|minus)) }

        lowerbound = { "lowerbound" }
        upperbound = { "upperbound" }

    // consumes all tokens until EOL
    info_string = ${ "string" ~ WS ~ tokens }

//
// helpers 
// 

// a token is a contiguous sequence of ascii alpha numeric characters
token = @{ ASCII_ALPHANUMERIC+ }

// tokens is a sequence of one or more white-space-separated tokens (not allowing newlines)
tokens = @{ token ~ (WS ~ token)* }

// digits is a contiguous sequence of ascii digits
digits = @{ ASCII_DIGIT+ }

millisecs = { digits }
integer = { (plus | minus)? ~ digits }
plus = { "+" }
minus = { "-" }




